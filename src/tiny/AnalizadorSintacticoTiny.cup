package tiny;

import java_cup.runtime.*;
import java.util.*;
import tiny.AnalizadorSintacticoTiny.*;
import modelo.constructoras.*;
import modelo.expresiones.*;
import modelo.instrucciones.*;
import modelo.operadores.*;
import modelo.tipos.*;

scan with {: return getScanner().next_token(); :};
parser code {: 
   private GestionErroresTiny errores;
   public void syntax_error(Symbol unidadLexica) {
     errores.errorSintactico((UnidadLexica)unidadLexica);
   }
   static Programa programaRaiz;
   static Constructoras cons;
   static class Campo {
   		public Campo(String id, Tipo tipo){ this.id = id; this.tipo = tipo; }
   		public String id;
   		public Tipo tipo;
   }
:};
init with {: 
   errores = new GestionErroresTiny();
   AnalizadorLexicoTiny alex = (AnalizadorLexicoTiny)getScanner();
   alex.fijaGestionErrores(errores);
   cons = new Constructoras();
:};

terminal PROGRAM, TYPES, STRUCT, POINTER, VARIABLES, SUBPROGRAMS, SUBPROGRAM, IF, ENDIF, DO, ENDDO, 
         MAS, MENOS, POR, DIV, MOD, AND, OR, NOT, TOINT, TODOUBLE, ASIG, IGUAL, MENOR, MAYOR, MENOROIGUAL, MAYOROIGUAL,
         DISTINTO, PYCOMA, COMA, PAP, PCIERRE, LLAVEAP, LLAVECIERRE, DOSPUNTOS, INT, BOOLEAN, DOUBLE, CAP, CCIERRE,
         PUNTO, FLECHA, AMP, TRUE, FALSE, ARRAY, READ, WRITE, NEW, DELETE;
terminal String NUMERO_NATURAL, NUMERO_REAL, ID;

non terminal Programa, SeccionTipos, SeccionVariables, SeccionSubprogramas, DecTipos, DecVariables, DecSubprogramas, DecTipo,
             Tipo, Campos, Campo, DecVariable, DecSubprograma, Parametros, ListaParametros, Parametro, Instruccion,
             IAsig, ICond, IBucle, IBloque, ILlamada, IRead, IWrite, INew, IDelete, Designador, Exp0, Exp1, Exp2, Exp3, 
             Exp4, Instrucciones, Casos, Caso, Argumentos, ListaArgumentos, OpComp, OpAditivo, OpMultiplicativo, 
             OpUnario;

Programa ::= PROGRAM SeccionTipos : st SeccionVariables : sv SeccionSubprogramas : ss IBloque : ib
	{: 
	RESULT = AnalizadorSintacticoTiny.programaRaiz = AnalizadorSintacticoTiny.cons
					.creaPrograma((DecTipos)st, (DecVariables)sv, (DecSubprogramas)ss, (Bloque)ib); 
	:};
	
SeccionTipos ::= TYPES DecTipos : dt
	{: RESULT = dt; :};
SeccionTipos ::= 
	{: RESULT = null; :};

SeccionVariables ::= VARIABLES DecVariables : dv
	{: RESULT = dv; :};
SeccionVariables ::= 
	{: RESULT = null; :};

SeccionSubprogramas ::= SUBPROGRAMS DecSubprogramas : ds
	{: RESULT = ds; :};
SeccionSubprogramas ::= 
	{: RESULT = null; :};

DecTipos ::= DecTipos : dts PYCOMA DecTipo : dt 
	{: 
		DecTipos dtsReal = (DecTipos) dts;
		DecTipos dtReal = (DecTipos) dt;
		RESULT = AnalizadorSintacticoTiny.cons.creaDecTipos(dtsReal, 
									dtReal.getIdentificador(), dtReal.getTipo()); 
	:};
DecTipos ::= DecTipo : dt 
	{: 
		RESULT = dt; 
	:};	
DecTipo ::= ID : id DOSPUNTOS Tipo : tipo
	{: 
		RESULT = AnalizadorSintacticoTiny.cons.creaDecTipos(null, id, (Tipo) tipo); 
	:};	

Tipo ::= INT 
	{: RESULT = AnalizadorSintacticoTiny.cons.creaInt(); :};
Tipo ::= DOUBLE 
	{: RESULT = AnalizadorSintacticoTiny.cons.creaDouble(); :};
Tipo ::= BOOLEAN 
	{: RESULT = AnalizadorSintacticoTiny.cons.creaBool(); :};
Tipo ::= ID : id
	{: RESULT = AnalizadorSintacticoTiny.cons.creaID(id); :};
Tipo ::= ARRAY Tipo : tipo CAP NUMERO_NATURAL : cap CCIERRE 
	{: 
		RESULT = AnalizadorSintacticoTiny.cons.creaArray(Integer.valueOf((String)cap), (Tipo) tipo); 
	:}; 
Tipo ::= STRUCT LLAVEAP Campos : campos LLAVECIERRE 
	{: 	
		List<String> ids = new ArrayList<String>();
		List<Tipo> tipos = new ArrayList<Tipo>();
		
		List<Campo> camposReal = (List<Campo>) campos;
		for (Campo c : camposReal){
			ids.add(c.id);
			tipos.add(c.tipo);
		}
		RESULT = AnalizadorSintacticoTiny.cons.creaStruct(ids, tipos); 
	:};
Tipo ::= POINTER Tipo : tipo
	{: 	RESULT = AnalizadorSintacticoTiny.cons.creaPuntero((Tipo) tipo); :};

Campos ::= Campos : cpos PYCOMA Campo : c
	{: 
		List<Campo> nuevosCampos = new ArrayList<Campo>(); 
		List<Campo> camposReal = (List<Campo>) cpos;
		for(Campo ca : camposReal){ nuevosCampos.add(ca); }
		nuevosCampos.add((Campo)c);	
		RESULT = nuevosCampos;
	:};
	
Campos ::= Campo : c 
	{: 	
		List<Campo> nuevosCampos = new ArrayList<Campo>(); 	
		nuevosCampos.add((Campo)c);
		RESULT = nuevosCampos;
	:};

Campo   ::= ID : id DOSPUNTOS Tipo : tipo
	{: 
		RESULT = new Campo(id, (Tipo) tipo);
	:};

DecVariables ::= DecVariables : dvs PYCOMA DecVariable : dv
	{:
		 DecVariables dvsReal = (DecVariables) dvs;
		 DecVariables dvReal = (DecVariables) dv;
		 RESULT = AnalizadorSintacticoTiny.cons.creaDecVariables(dvsReal,
		 								 dvReal.getIdentificador(), dvReal.getTipo()); 
	:};
	
DecVariables ::= DecVariable : dv
	{:
		 RESULT = dv;
	:};
	
DecVariable ::= ID : id DOSPUNTOS Tipo : tipo
	{:		
		 RESULT = AnalizadorSintacticoTiny.cons.creaDecVariables(null, id, (Tipo)tipo); 
	:};
	
DecSubprogramas ::= DecSubprogramas : dss PYCOMA DecSubprograma : ds
	{:		
		 DecSubprogramas dssReal = (DecSubprogramas) dss;
		 DecSubprogramas dsReal = (DecSubprogramas) ds;
		 RESULT = AnalizadorSintacticoTiny.cons.creaDecSubprogramas(dssReal, 
		 									dsReal.getIdentificador(), 
		 									dsReal.getParametros(), 
		 									dsReal.getPrograma()); 
	:};
	
DecSubprogramas ::= DecSubprograma : ds
	{:		
		 RESULT = ds; 
	:};
	
DecSubprograma ::= SUBPROGRAM ID : id Parametros : params
				SeccionTipos : tipos SeccionVariables : vars SeccionSubprogramas : ss IBloque : bloque
	{:		
		 RESULT = AnalizadorSintacticoTiny.cons.creaDecSubprogramas(null, id, ((List<Parametro>) params), 
				AnalizadorSintacticoTiny.cons.
				creaPrograma((DecTipos)tipos, (DecVariables)vars, (DecSubprogramas)ss, (Bloque)bloque)); 
	:};
	
Parametros ::= PAP ListaParametros : lp PCIERRE  
	{:
		RESULT = lp;
	:};	

Parametros ::= PAP PCIERRE
	{:
		RESULT = new ArrayList<Parametro>();
	:};
	
ListaParametros ::= ListaParametros : lp COMA Parametro : p
	{:
		List<Parametro> pars = (ArrayList<Parametro>) lp;
		pars.add((Parametro)p);		
		RESULT = pars;
	:};

ListaParametros ::= Parametro : p
	{:
		List<Parametro> pars = new ArrayList<Parametro>();
		pars.add((Parametro)p);
		RESULT = pars;
	:};
	
Parametro ::= ID : id DOSPUNTOS Tipo : tipo
	{:
		RESULT = AnalizadorSintacticoTiny.cons.creaParametro(true, id, (Tipo) tipo);
	:};

Parametro ::= AMP ID : id DOSPUNTOS Tipo : tipo
	{:
		RESULT = AnalizadorSintacticoTiny.cons.creaParametro(false, id, (Tipo) tipo);
	:};
	
Instruccion ::= IAsig : ins 
	{: 
		RESULT = ins; 	
	:};
Instruccion ::= IBloque : ins 
	{: 
		RESULT = ins; 	
	:};
Instruccion ::= ICond : ins 
	{: 
		RESULT = ins; 	
	:};
Instruccion ::= IBucle : ins 
	{: 
		RESULT = ins; 	
	:};
Instruccion ::= ILlamada : ins 
	{: 
		RESULT = ins; 	
	:};
Instruccion ::= IRead : ins 
	{: 
		RESULT = ins; 	
	:};
Instruccion ::= IWrite : ins 
	{: 
		RESULT = ins; 	
	:};
Instruccion ::= INew : ins 
	{: 
		RESULT = ins; 	
	:};
Instruccion ::= IDelete : ins 
	{: 
		RESULT = ins; 	
	:};	
                
IAsig ::= Designador : ds ASIG Exp0 : e
	{:
		RESULT = AnalizadorSintacticoTiny.cons.creaAsignacion((Designador)ds, (Expresion)e);
	:};
	
IBloque ::= LLAVEAP Instrucciones : inst LLAVECIERRE 
	{:
		RESULT = AnalizadorSintacticoTiny.cons.creaBloque((List<Instruccion>) inst);		
	:};

IBloque ::= LLAVEAP LLAVECIERRE
	{:
		RESULT = null;
	:};
	
Instrucciones ::= Instrucciones : inst PYCOMA Instruccion : i
	{:
		List<Instruccion> list = (List<Instruccion>) inst;
		list.add((Instruccion)i);
		RESULT = list;	
	:};

Instrucciones ::= Instruccion : i
	{:
		List<Instruccion> list = new ArrayList<Instruccion>();
		list.add((Instruccion)i);
		RESULT = list;
	:};
	
ICond ::= IF Casos : c ENDIF
	{:
		RESULT = AnalizadorSintacticoTiny.cons.creaCasos((Casos) c, (Expresion) null, (Bloque) null);	
	:};
	
Casos ::= Casos : cs CAP CCIERRE Caso : ca
	{:
		Casos caReal = (Casos) ca;
		RESULT = AnalizadorSintacticoTiny.cons.creaCasos((Casos) cs, caReal.getExpresion(), caReal.getBloque());			
	:};

Casos ::= Caso : c
	{:
		RESULT = AnalizadorSintacticoTiny.cons.creaCasos((Casos) c, (Expresion) null, (Bloque) null);			
	:};
	
Caso  ::= Exp0 : e DOSPUNTOS IBloque : b
	{:
		RESULT = AnalizadorSintacticoTiny.cons.creaCasos(null, (Expresion) e, (Bloque) b);			
	:};
	
IBucle ::= DO Casos : c ENDDO
	{:
		RESULT = AnalizadorSintacticoTiny.cons.creaBucle((Casos) c);		
	:};
	
ILlamada  ::= ID : id Argumentos : args
	{:		
		RESULT = AnalizadorSintacticoTiny.cons.creaLlamada(id, (List<Expresion>) args);
	:};
	
IRead ::= READ Designador: d
	{: RESULT = AnalizadorSintacticoTiny.cons.creaRead((Designador) d); :};
	
IWrite ::= WRITE Exp0 : e
	{: RESULT = AnalizadorSintacticoTiny.cons.creaWrite((Expresion) e); :};
	
INew ::= NEW Designador : d
	{: RESULT = AnalizadorSintacticoTiny.cons.creaNew((Designador) d); :};
	
IDelete ::= DELETE Designador : d
	{: RESULT = AnalizadorSintacticoTiny.cons.creaDelete((Designador) d); :};
	
Argumentos ::= PAP ListaArgumentos : la PCIERRE 
	{:
		RESULT = la;
	:};

Argumentos ::= PAP PCIERRE
	{:
		RESULT = null;	
	:};
	
ListaArgumentos ::= ListaArgumentos : la COMA Exp0 : e
	{:	
		List<Expresion> las = new ArrayList<Expresion>();
		for (Expresion exp : (List<Expresion>)la){ las.add((Expresion)la); }
		las.add((Expresion)e);
		RESULT = las;	
	:};

ListaArgumentos ::= Exp0 : e
	{:
		RESULT = AnalizadorSintacticoTiny.cons.creaArgumentos((Expresion) e);
	:};
	

Designador  ::= ID : id
	{: RESULT = AnalizadorSintacticoTiny.cons.creaDesignador(id); :};
Designador  ::= Designador : d CAP Exp0 : e CCIERRE
	{: RESULT = AnalizadorSintacticoTiny.cons.creaDesignador((Designador)d, (Expresion)e); :};
Designador  ::= Designador : d PUNTO ID : id
	{: RESULT = AnalizadorSintacticoTiny.cons.creaDesignador((Designador)d, id); :};
Designador  ::= Designador : d FLECHA
	{: RESULT = AnalizadorSintacticoTiny.cons.creaDesignador((Designador)d, ""); :};

Exp0 ::= Exp1 : e0 OpComp : op Exp1 : e1 
	{: RESULT = AnalizadorSintacticoTiny.cons.creaExpresionBinaria((Expresion) e0,
																   (OpBinario) op,
																   (Expresion) e1); :};
Exp0 ::= Exp1 : e
	{: RESULT = e; :};
Exp1 ::= Exp1 : e0 OpAditivo : op Exp2 : e1
	{: RESULT = AnalizadorSintacticoTiny.cons.creaExpresionBinaria((Expresion) e0,
																   (OpBinario) op,
																   (Expresion) e1); :};
Exp1 ::= Exp2 : e
	{: RESULT = e; :};
Exp2 ::= Exp2 : e0 OpMultiplicativo : op Exp3 : e1
	{: RESULT = AnalizadorSintacticoTiny.cons.creaExpresionBinaria((Expresion) e0,
																   (OpBinario) op,
																   (Expresion) e1); :};
Exp2 ::= Exp3 : e
	{: RESULT = e; :};
Exp3 ::= OpUnario : op Exp3 : e0
	{: RESULT = AnalizadorSintacticoTiny.cons.creaExpresionUnaria((OpUnario) op,
																   (Expresion) e0); :};
Exp3 ::= Exp4 : e
	{: RESULT = e; :};

Exp4 ::= TRUE 
	{: RESULT = AnalizadorSintacticoTiny.cons.creaExpresionBoolean(true); :};
Exp4 ::= FALSE
	{: RESULT = AnalizadorSintacticoTiny.cons.creaExpresionBoolean(false); :};
Exp4 ::= NUMERO_NATURAL : v
	{: RESULT = AnalizadorSintacticoTiny.cons.creaExpresionInteger(Integer.valueOf((String)v)); :};
Exp4 ::= NUMERO_REAL : v
	{: RESULT = AnalizadorSintacticoTiny.cons.creaExpresionDouble(Double.valueOf((String)v)); :};
Exp4 ::= Designador : d
	{: RESULT = AnalizadorSintacticoTiny.cons.creaExpresionDesignador((Designador)d); :};
Exp4 ::= PAP Exp0 PCIERRE;



OpComp ::= IGUAL  : v
	{: RESULT = AnalizadorSintacticoTiny.cons.creaOpBinario((String)v); :};
OpComp ::= DISTINTO : v
	{: RESULT = AnalizadorSintacticoTiny.cons.creaOpBinario((String)v); :};
OpComp ::= MAYOR  : v
	{: RESULT = AnalizadorSintacticoTiny.cons.creaOpBinario((String)v); :};
OpComp ::= MAYOROIGUAL  : v
	{: RESULT = AnalizadorSintacticoTiny.cons.creaOpBinario((String)v); :};
OpComp ::= MENOR  : v
	{: RESULT = AnalizadorSintacticoTiny.cons.creaOpBinario((String)v); :};
OpComp ::= MENOROIGUAL : v
	{: RESULT = AnalizadorSintacticoTiny.cons.creaOpBinario((String)v); :};	
	

OpAditivo ::= OR  : v
	{: RESULT = AnalizadorSintacticoTiny.cons.creaOpBinario((String)v); :};
OpAditivo ::= MENOS : v
	{: RESULT = AnalizadorSintacticoTiny.cons.creaOpBinario((String)v); :};
OpAditivo ::= MAS : v
	{: RESULT = AnalizadorSintacticoTiny.cons.creaOpBinario((String)v); :};

OpMultiplicativo ::= AND  : v
	{: RESULT = AnalizadorSintacticoTiny.cons.creaOpBinario((String)v); :};
OpMultiplicativo ::= MOD : v
	{: RESULT = AnalizadorSintacticoTiny.cons.creaOpBinario((String)v); :};
OpMultiplicativo ::= DIV : v
	{: RESULT = AnalizadorSintacticoTiny.cons.creaOpBinario((String)v); :};
OpMultiplicativo ::= POR : v
	{: RESULT = AnalizadorSintacticoTiny.cons.creaOpBinario((String)v); :};

OpUnario ::= TODOUBLE  : v
	{: RESULT = AnalizadorSintacticoTiny.cons.creaOpUnario((String)v); :};
OpUnario ::= MENOS : v
	{: RESULT = AnalizadorSintacticoTiny.cons.creaOpUnario((String)v); :};
OpUnario ::= NOT : v
	{: RESULT = AnalizadorSintacticoTiny.cons.creaOpUnario((String)v); :};
OpUnario ::= TOINT : v
	{: RESULT = AnalizadorSintacticoTiny.cons.creaOpUnario((String)v); :};


 







